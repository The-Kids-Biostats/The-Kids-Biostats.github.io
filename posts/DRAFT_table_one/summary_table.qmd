---
title: "Summary Tabling in R"
author: "Zac Dempsey"
format:
  html:
    code-fold: true
    toc: true
    toc-location: left
date: "2024-07-01"
categories:
  - R
  - Summary
draft: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
suppressMessages(library(tidyverse))
library(gtsummary)
library(summarytools)
library(desctable)
library(tableone)
```

# Overview

Analysing data will normally always involve generating tables– whether they are the final goal of the analysis or used as an intermediary step to guide further analysis. This blog post will focus on the former, while keeping the latter in the back of our minds. A common use case here might be a "Table 1" from a randomised control trial where we are examining (not testing and generating p-values) a range of summary statistics for each arm of the trial, or perhaps data are collected on a group over three time points and we want to examine a range of summary statistics for each time point.

There are *many* `R` packages and functions dedicated to this very task. We will select just a handful that we often come across in our work, and evaluate their effectiveness relative to some pre-set criteria we deem important in our work. Example code and commentary will be presented as we go.

<br>

# Assessment Criteria

1.  **Range of customisible summary options**

    -   How flexible are the summary functions to different metrics (mean, median, SD, IQR)?

    -   How easy is it to apply these changes to different data types (e.g., continuous, dichotomous, ordinal, nominal).

2.  **Flexibility in changing tabling output**

    -   Text formatting (italics, bolding, font size, etc.)

    -   Specifying order for table elements

    -   Rounding

3.  **Rendering across different output types**

    -   Are the outputs robust with respect to output form (html, pdf, word)?

<br>

# Contenders

Let's define our set of contenting packages. Keep in mind this is not an exhaustive list of all summary and tabling functions – we select only a few that we often use or come across in our work. Any function is considered that is capable of presenting a formatted summary table in html, pdf and/or Word form. Therefore, the various summary tabling functions that print output to console (e.g., `Hmisc::describe`, `tableone::CreateTableOne`) are not considered.

-   [`gtsummary::tbl_summary`](https://www.danieldsjoberg.com/gtsummary/)
-   [`table1::table1`](https://cran.r-project.org/web/packages/table1/vignettes/table1-examples.html)
-   [`desctable::desc_table`](https://cran.r-project.org/web/packages/desctable/vignettes/desctable.html)
-   [`summarytools::dfSummary`](https://rdrr.io/cran/summarytools/man/dfSummary.html)
-   [`janitor::tabyl`](https://cran.r-project.org/web/packages/janitor/vignettes/tabyls.html)
-   [`stargazer::stargazer`](https://cran.r-project.org/web/packages/stargazer/vignettes/stargazer.pdf)
-   tableone
-   [custom](https://mcfromnz.wordpress.com/2010/09/21/automatic-descriptive-statistic-tables/)

<br>

# Data

## Sample Dataset

To evaluate the summary table functions, we select a data set and make a few minor changes to ensure it has the right variety of variables types to test all of our required scenarios.

We will use the `flchain` (Assay of serum free light chain for 7874 subjects) dataset from the `survival` package.

```{r}
data(flchain, package = "survival")

head(flchain)
str(flchain)
```

This has the following variable types

-   Continuous (numeric)

    -   `age`

    -   `kappa`

    -   `lambda`

    -   `futime`

    -   `creatinine`

-   Ordinal

    -   `sample.yr`

    -   `death`

    -   `chapter`

-   Nominal

    -   `sex`

    -   `mgus`

    -   `flc.grp`

<p>

## Objectives

For each method, we will:

-   Report median (interquartile range) for `age` and mean (standard deviation) for all other continuous (numeric) variables.
-   Apply level specifications to ordinal variables (`sample.yr`)
-   Stratify results by `death`.
-   Report the `lambda` statistics to 1 decimal place.
-   Rename sample.yr to Sample Year.
-   Render in html, pdf and word and compare consistency across these.

Where any of the above was seemingly not possible, it will be reported in the comments of that method. Comments will also be made on the quality of the documentation for each package and the wealth of online support through StackOverflow, blogs, tutorials, etc.

# Summary Tables

## Method 1 - `gtsummary`

-   Required data structure:
    -   In general, `tbl_summary` requires data in **long format**. This is consistent across both the `tbl_summary` and `tbl_strata` functions.
    -   "Columns" in the output are defined by use of the `by =` argument.
    -   "Rows" in the output are defined by columns in the input data set.
    -   All variables included in the input data are, by default, included in the output. Therefore, the user must select/un-select columns pursuant to what is required.

```{r echo = T}

#tf <- tempfile("example", fileext = ".docx")

flchain %>%
  gtsummary::tbl_summary(by = "death", # Levels to separate data by
                         missing = "ifany", # Show missing values for a variable only if they exist
                         digits = list(all_categorical() ~ c(0, 2), # Categorical counts 0dp; relative percentage 2dp
                                       all_continuous() ~ 2, # Continuous summary stats 2dp
                                       lambda ~ 1), # Report stats for `lambda` to 1dp
                         type = all_continuous() ~ "continuous2", # Define multi-level summary stats for all continuous variables
                         statistic = list(all_continuous() ~ c("{mean} ({sd})",            # Display mean & standard deviation
                                                               "{median} ({p25}, {p75})"), # Display median & IQR
                                          all_categorical() ~ "{n} ({p}%)"),               # Display count & percentage
                         label = list(sample.yr ~ "Sample Year")) %>% # Amend label of `sample.yr`
  
  add_overall(last = TRUE) %>% # Add overall counts, set to `last` column of output
  italicize_labels() %>% # Italicize variable labels
  
  add_p(test = list(all_categorical() ~ "chisq.test", # Apply chi square test to all categorical variables
                    c(kappa, lambda) ~ "t.test", # Apply t.test to `kappa`, `lambda`
                    c(flc.grp, creatinine) ~ "kruskal.test"), # Apply Kruskal-Wallis test to `flc.grp` and `creatinine`
        test.args = list(all_tests("t.test") ~ list(var.equal = F, # Equal variance assumption for t-test FALSE
                                                       paired = F), # Paired t-test FALSE
                         all_tests("chisq.test") ~ list(correct = F)), # Continuity correction = FALSE to chi-square test                                                   
        pvalue_fun = function(x) style_pvalue(x, digits = 3)) # Set p-value rounding (`gtsummary::style_pvalue` supports only values 1, 2, 3)
  #as_gt() %>% 
  #gt::gtsave(filename = "example.docx")

```

<p>

-   For stratified tables, we can use `tbl_summary` inside of the `tbl_strata` function. Take for example the below, which stratifies by `sex`.

```{r echo = T}

flchain %>%
  tbl_strata(strata = sex, 
             .tbl_fun = ~.x %>%
  gtsummary::tbl_summary(by = "death",
                         # test 1
                         digits = lambda ~ 1,
                         label = sample.yr ~ "Sample Year") %>%
  add_overall(last = TRUE) %>%
  italicize_labels() %>%
  add_p())
```

### Comments (pros/cons)

-   **Pros**
    -   Massive amount of options/variability in output
    -   Formatting is very nice in html form.
    -   Easy to add in and specify arguments to testing.
-   **Cons**
    -   Does not render in Word document markdown format (can save output to Word document).
    -   Can be a bit clumsy when specifying some arguments (must be inside list, etc.)
    -   Can be annoying when working with high dimensional data (selecting large number of columns).
    -   When applying multiple tests within a class of variables (e.g., t-test for one continuous variable, Kruskal-Wallis test for another) it is not obvious which test is applied to which. Only the p-value is returned in each instance.

<br>

## Method 4 - `tableone`

```{r echo = T}
tableone::CreateTableOne(data = flchain,
                         strata = "death",
                         test = TRUE,
                         testApprox = chisq.test, # For categorical variables (where Chi-Square approximation is appropriate), apply chi-square test
                         argsApprox = list(correct = T), # Arguments to above
                         
                         testExact = fisher.test, # For categorical variables with small counts, apply Fisher's test
                         argsExact = list(workspace = 2*10^5), # Arguments to above
                         
                         testNormal = oneway.test, # For normally distributed continuous variables, apply one-way test (==t.test if 2 groups)
                         argsNormal = list(var.equal = T), # Arguments to above
                         
                         testNonNormal = kruskal.test, # For non-normally distributed continuous variables, apply Kruskal-Wallis rank-sum test
                         argsNonNormal = list(NULL), # Arguments to above
                         
                         addOverall = T # Add overall column
                         )
```

### Comments (pros/cons)

-   **Pros**
    -   Implicitly tests each variable for appropriateness of test (e.g., normal vs. non-normal etc.)
    -   Seems like a good "first pass" sort of function to apply in cases where we have a lot of variables. Perhaps less so a "publication ready" function.
-   **Cons**
    -   Renders nicely to console, not so much to Rmarkdown (relative to above)
    -   Clunky to specify testing
        -   Cannot easily tell which test is being applied to which variable (cannot tell whether variable is "normal" vs. "non-normal")
        -   Different arguments specified for approximate vs. exact categorical tests (chi-square vs. Fisher's test) and normal vs. non-normal continuous tests (t-test vs. Kruskal-Wallis Rank-Sum test)
    -   Output is clunky and cannot be tweaked (decimal places, structure of output)

<br>

## Method 5 - `desctable`

```{r echo = T}
flchain %>% 
  group_by(death) %>%
  desctable::desc_table("N"    = length,
                        "Min"  = min,
                        "Q1"   = ~quantile(., .25),
                        "Med"  = median,
                        "Mean" = mean,
                        "Q3"   = ~quantile(., .75),
                        "Max"  = max,
                        "sd"   = sd,
                        "IQR"  = IQR) %>%
  #desctable::desc_tests() %>%
  desctable::desc_output("DT")
```

### Comments (pros/cons)

-   **Pros**
    -   Interactive table
    -   Can copy output directly to clipboard, excel (with interactive button)
-   **Cons**
    -   Must specify grouping variables outside of the `desctable` environment
    -   Is slooow.
    -   Specification of tests are a little clunky and troublesome with categorical factors.
    -   Specification of statistics between categorical and continuous variables are a little clunky (shows IQR for categorical variables, etc.)

<br>

<br>

## Method 6 - `summarytools`

```{r echo = T, results = "asis", cache = FALSE}
flchain %>%
  group_by(death) %>%
  summarytools::dfSummary(round.digits = 2) %>%
  base::print(.)
```

### Comments

-   **Pros**
    -   Has some pretty cool graphs
-   **Cons**
    -   A bit fiddly to render nicely in RMarkdown. Requires specification of additional arguments in chunk header (`results = asis`)
    -   Stratification is clunky in output, and requires manual `group_by` argument.

<br>

## Acknowledgements

Thanks to Wesley Billingham, Matt Cooper, and Elizabeth McKinnon for providing feedback on and reviewing this post.

You can look forward to seeing posts from these other team members here in the coming weeks and months.

<br>

## Reproducibility Information

To access the .qmd (Quarto markdown) files as well as any R scripts or data that was used in this post, please visit our GitHub:

<https://github.com/The-Kids-Biostats/The-Kids-Biostats.github.io/tree/main/posts/parallel>

The session information can also be seen below.

```{r echo = T}
sessionInfo()
```

```{r echo = F , warning = F, message = F, error = F}
rm(trials, results, i, j, model, outcome_vars, input_vars, start, end, ind, bootstrap_results, bootstrap_coefs, bootstrap_cis, mtcars, result, month_dat, flights)
```
