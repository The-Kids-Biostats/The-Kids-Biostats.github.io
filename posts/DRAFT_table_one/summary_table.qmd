---
title: "Summary Tabling in R"
author: "Zac Dempsey"
format:
  html:
    code-fold: true
    tabset: true
    toc: true
    toc-location: left
date: "2024-07-01"
categories:
  - R
  - Summary
draft: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
suppressMessages(library(tidyverse))
#library(gtsummary)
#library(summarytools)
#library(desctable)
#library(tableone)
```

# Overview

Analysing data will normally always involve generating tables– whether they are the final goal of the analysis or used as an intermediary step to guide further analysis. This blog post will focus on the former, while keeping the latter in the back of our minds. A common use case here might be a "Table 1" from a randomised control trial where we are examining (not testing and generating p-values) a range of summary statistics for each arm of the trial, or perhaps data are collected on a group over three time points and we want to examine a range of summary statistics for each time point.

There are *many* `R` packages and functions dedicated to this very task. We will select just a handful that we often come across in our work, and evaluate their effectiveness relative to some pre-set criteria we deem important in our work. Example code and commentary will be presented as we go.

<br>

# Assessment Criteria

1.  **Range of customisible summary options**

    -   How flexible are the summary functions to different metrics (mean, median, SD, IQR)?

    -   How easy is it to apply these changes to different data types (e.g., continuous, dichotomous, ordinal, nominal).

2.  **Flexibility in changing tabling output**

    -   Text formatting (italics, bolding, font size, etc.)

    -   Specifying order for table elements

    -   Rounding

3.  **Rendering across different output types**

    -   Are the outputs robust with respect to output form (html, pdf, word)?

<br>

# Contenders

Let's define our set of contenting packages. Keep in mind this is not an exhaustive list of all summary and tabling functions – we select only a few that we often use or come across in our work. Any function is considered that is capable of presenting a formatted summary table in html, pdf and/or Word form. Therefore, the various summary tabling functions that print output to console (e.g., `Hmisc::describe`) are not considered.

-   [`gtsummary::tbl_summary`](https://www.danieldsjoberg.com/gtsummary/)
-   [`table1::table1`](https://cran.r-project.org/web/packages/table1/vignettes/table1-examples.html)
-   [`desctable::desc_table`](https://cran.r-project.org/web/packages/desctable/vignettes/desctable.html)
-   [`summarytools::dfSummary`](https://rdrr.io/cran/summarytools/man/dfSummary.html)
-   [`janitor::tabyl`](https://cran.r-project.org/web/packages/janitor/vignettes/tabyls.html)
-   [`stargazer::stargazer`](https://cran.r-project.org/web/packages/stargazer/vignettes/stargazer.pdf)
-   tableone
-   [custom](https://mcfromnz.wordpress.com/2010/09/21/automatic-descriptive-statistic-tables/)

<br>

# Data

## Sample Dataset

To evaluate the summary table functions, we select a data set and make a few minor changes to ensure it has the right variety of variables types to test all of our required scenarios.

We will use the `flchain` (Assay of serum free light chain for 7874 subjects) dataset from the `survival` package.

```{r}
data(flchain, package = "survival")

head(flchain)
str(flchain)
```

<p>

This has the following variable types

+---------------+------------------+
| Continuous    | -   `age`        |
|               |                  |
|               | -   `kappa`      |
|               |                  |
|               | -   `lambda`     |
|               |                  |
|               | -   `futime`     |
|               |                  |
|               | -   `creatinine` |
+---------------+------------------+
| Ordinal       | -   `sample.yr`  |
|               |                  |
|               | -   `death`      |
|               |                  |
|               | -   `chapter`    |
+---------------+------------------+
| Nominal       | -   `sex`        |
|               |                  |
|               | -   `mgus`       |
|               |                  |
|               | -   `flc.grp`    |
+---------------+------------------+

<p>

## Objectives

For each method, we will:

-   Stratify results by `sex`.
-   Report median (interquartile range) for `age` and mean (standard deviation) for all other continuous (numeric) variables.
-   Apply level specifications to ordinal variables (`sample.yr`)
-   Round continuous values to 1 decimal places.
-   Apply nicely formatted labels to all variables
-   Apply basic statistical to quantify any differences between the stratified death groups.
    -   Chi-square test for categorical variables
    -   Kruskal-Wallis test for continuous variables.
-   Add overall summary statistics across all levels of the stratification variable.
-   Render in html, pdf and word and compare consistency across these.

Where any of the above was seemingly not possible, it will be reported in the comments of that method. Comments will also be made on the quality of the documentation for each package and the wealth of online support through StackOverflow, blogs, tutorials, etc.

<br>

# 1) `gtsummary::tbl_summary`

## i) Render table

-   Required data structure:
    -   In general, `tbl_summary` requires data in **long format**. This is consistent across both the `tbl_summary` and `tbl_strata` functions.
    -   "Columns" in the output are defined by use of the `by =` argument.
    -   "Rows" in the output are defined by columns in the input data set.
    -   All variables included in the input data are, by default, included in the output. Therefore, the user must select/un-select columns pursuant to what is required.

```{r echo = T}
suppressWarnings(library(gtsummary))

sumtab1 <- flchain %>%
  mutate(death = case_match(death, 
                          0 ~ "Alive at last contact date", 
                          1 ~ "Dead"),
         sex = case_match(sex,
                          "F" ~ "Female",
                          "M" ~ "Male")) %>%
  
  gtsummary::tbl_summary(by = "death",
                         digits = list(all_categorical() ~ c(0, 1),
                                       all_continuous() ~ 1),
                         statistic = list(all_continuous() ~ "{mean} ({sd})",
                                          age ~ "{median} ({p25}, {p75})"),       
                         label = list(sample.yr ~ "Sample Year",
                                      sex ~ "Sex",
                                      age ~ "Age (years)",
                                      kappa ~ "Serum free light chain: kappa portion",
                                      lambda ~ "Serum free light chain: lambda portion",
                                      flc.grp ~ "FLC group",
                                      creatinine ~ "Serum creatinine",
                                      mgus ~ "Monoclonal gammapothy diagnosis",
                                      futime ~ "Time from enrolment until death (days)",
                                      chapter ~ "Primary cause of death")) %>%
  gtsummary::add_overall(last = TRUE)
```

## ii) Output table

Print this to html

```{r}
sumtab1
```

Render to word doc

```{r}
sumtab1_word <- sumtab1 %>%
  gtsummary::as_flex_table(.)

officer::read_docx() %>%
  flextable::body_add_flextable(sumtab1_word) %>%
  print(target = "sumtab1.docx")
```

![Word document format](sumtab1_word.png){fig-align="center"}

## iii) Comments

-   **Pros**
    -   Massive amount of options/variability in output
    -   Formatting is very nice in html form.
    -   Easy to add in and specify arguments to testing.
-   **Cons**
    -   Does not render in Word document markdown format (can save output to Word document).
    -   Can be a bit clumsy when specifying some arguments (must be inside list, etc.)
    -   Can be annoying when working with high dimensional data (selecting large number of columns).
    -   When applying multiple tests within a class of variables (e.g., t-test for one continuous variable, Kruskal-Wallis test for another) it is not obvious which test is applied to which. Only the p-value is returned in each instance.

<br>

# 2) `table1::table1`

## i) Render table

```{r}
suppressMessages(suppressWarnings(library(table1)))

flchain_mod <- flchain

# Re-code categorical variable levels
flchain_mod <- flchain_mod %>%
  mutate(sex = case_match(sex, 
                          "F" ~ "Female", 
                          "M" ~ "Male"),
         mgus = case_match(mgus, 
                           0 ~ "No", 
                           1 ~ "Yes"),
         death = case_match(death, 
                            0 ~ "Alive at last contact date", 
                            1 ~ "Dead"),
         sample.yr = as_factor(sample.yr))

# Custom rendering function to apply formatting to table
rndr <- function(x, name, ...) {
  if (!is.numeric(x)) 
    return(table1::render.categorical.default(x, 
                                              na.is.category = FALSE,
                                              digits.pct = 1
                                              ))
  
  sum_stats <- if (name %in% c("age")){
    "Median [Q1, Q3]"
  } else {
    "Mean (SD)"
  }
  table1::parse.abbrev.render.code(c("", sum_stats))(x)
}

#pvalue <- function(x, ...) {
#    # Construct vectors of data y, and groups (strata) g
#    y <- unlist(x)
#    g <- factor(rep(1:length(x), times=sapply(x, length)))
#    if (is.numeric(y)) {
#        # For numeric variables, perform a standard 2-sample t-test
#        p <- t.test(y ~ g)$p.value
#    } else {
#        # For categorical variables, perform a chi-squared test of independence
#        p <- chisq.test(table(y, g))$p.value
#    }
#    # Format the p-value, using an HTML entity for the less-than sign.
#    # The initial empty string places the output on the line below the variable #label.
#    c("", sub("<", "&lt;", format.pval(p, digits=3, eps=0.001)))
#}

# Specify variable labels
label(flchain_mod$age)        <-"Age (years)"
label(flchain_mod$sex)        <- "Sex"
label(flchain_mod$sample.yr)  <- "Sample Year"
label(flchain_mod$kappa)      <- "Serum free light chain: kappa portion"
label(flchain_mod$lambda)     <- "Serum free light chain: lambda portion"
label(flchain_mod$flc.grp)    <- "FLC group"
label(flchain_mod$creatinine) <- "Serum creatinine"
label(flchain_mod$mgus)       <- "Monoclonal gammapothy diagnosis"
label(flchain_mod$futime)     <- "Time from enrolment until death (days)"
label(flchain_mod$chapter)    <- "Primary cause of death"

# Specify table output
sumtab2 <- flchain_mod %>%
  table1::table1(~ age +  
                   sample.yr + 
                   kappa + 
                   lambda + 
                   flc.grp + 
                   creatinine + 
                   mgus + 
                   futime + 
                   sex + 
                   chapter | death, 
                 data = .,
                 overall = c(right = "Overall"),
                 #extra.col = list(`p-value` = pvalue),
                 render = rndr # Call the custom rendering function from above
                 )
```

## ii) Output table

```{r}
sumtab2
```

```{r}
#sumtab2_table1 <- sumtab2 %>%
#  flextable::as_flextable()

#officer::read_docx() %>%
#  flextable::body_add_flextable(sumtab1_word) %>%
#  print(target = "sumtab1.docx")
```

<br>

# 3) `tableone::CreateTableOne`

## i) Render table

```{r echo = T}
suppressWarnings(library(tableone))

flchain_mod <- flchain %>%
  mutate(sex = case_match(sex, 
                          "F" ~ "Female", 
                          "M" ~ "Male"),
         mgus = case_match(mgus, 
                           0 ~ "No", 
                           1 ~ "Yes"),
         death = case_match(death, 
                            0 ~ "Alive at last contact date", 
                            1 ~ "Dead"))

# Specify variable labels
label(flchain_mod$age)        <- "Age (years)"
label(flchain_mod$sex)        <- "Sex"
label(flchain_mod$sample.yr)  <- "Sample Year"
label(flchain_mod$kappa)      <- "Serum free light chain: kappa portion"
label(flchain_mod$lambda)     <- "Serum free light chain: lambda portion"
label(flchain_mod$flc.grp)    <- "FLC group"
label(flchain_mod$creatinine) <- "Serum creatinine"
label(flchain_mod$mgus)       <- "Monoclonal gammapothy diagnosis"
label(flchain_mod$futime)     <- "Time from enrolment until death (days)"
label(flchain_mod$chapter)    <- "Primary cause of death"


sumtab3 <- flchain_mod %>%
    #mutate(sex = case_match(sex, 
    #                      "F" ~ "Female", 
    #                      "M" ~ "Male"),
    #     mgus = case_match(mgus, 
    #                       0 ~ "No", 
    #                       1 ~ "Yes"),
    #     death = case_match(death, 
    #                        0 ~ "Alive at last contact date", 
    #                        1 ~ "Dead")) %>%
  sjlabelled::label_to_colnames() %>%
  tableone::CreateTableOne(data = .,
                           strata = "death", 
                           test = FALSE,
                           factorVars = c("sex", "sample.yr", "flc.grp", "mgus", "chapter"),
                           addOverall = TRUE)

mean_sd <- function(x) c(mean = mean(x, na.rm = TRUE), sd = sd(x, na.rm = TRUE))
summary_stats <- list(age = function(x) c(median = median(x, na.rm = TRUE), 
                                          IQR = IQR(x, na.rm = TRUE)),
                      kappa = mean_sd,
                      lambda = mean_sd,
                      creatinine = mean_sd,
                      futime = mean_sd
                      )

sumtab3 <- print(sumtab3,
      showAllLevels = TRUE,
      nonnormal = names(summary_stats),
      contStats = summary_stats,
      digits = 1,
      quote = FALSE,
      noSpaces = TRUE,
      printToggle = FALSE) %>%
  knitr::kable(., format = "html")
```

## ii) Output table

```{r}
sumtab3
```

## iii) Comments

-   **Pros**
    -   Implicitly tests each variable for appropriateness of test (e.g., normal vs. non-normal etc.)
    -   Seems like a good "first pass" sort of function to apply in cases where we have a lot of variables. Perhaps less so a "publication ready" function.
-   **Cons**
    -   Renders nicely to console, not so much to Rmarkdown (relative to above)
    -   Clunky to specify testing
        -   Cannot easily tell which test is being applied to which variable (cannot tell whether variable is "normal" vs. "non-normal")
        -   Different arguments specified for approximate vs. exact categorical tests (chi-square vs. Fisher's test) and normal vs. non-normal continuous tests (t-test vs. Kruskal-Wallis Rank-Sum test)
    -   Output is clunky and cannot be tweaked (decimal places, structure of output)

<br>

# 4) `desctable::desc_table`

## i) Render table

```{r echo = T}
labels <- list(sample.yr  = "Sample Year",
               sex        = "Sex",
               age        = "Age (years)",
               kappa      = "Serum free light chain: kappa portion",
               lambda     = "Serum free light chain: lambda portion",
               flc.grp    = "FLC group",
               creatinine = "Serum creatinine",
               mgus       = "Monoclonal gammapothy diagnosis",
               futime     = "Time from enrolment until death (days)",
               chapter    = "Primary cause of death")

sumtab4 <- flchain %>% 
  group_by(death) %>%
  desctable::desc_table(data = .,
                        .labels = labels) %>% #,
                        #"N"    = length,
                        #"Min"  = min,
                        #"Q1"   = ~quantile(., .25),
                        #"Med"  = median,
                        #"Mean" = mean,
                        #"Q3"   = ~quantile(., .75),
                        #"Max"  = max,
                        #"sd"   = sd,
                        #"IQR"  = IQR,
                        #labels = list(
                        #      sample.yr = "Sample Year",
                        #      sex = "Sex",
                        #      age = "Age (years)",
                        #      kappa = "Serum free light chain: kappa portion",
                        #      lambda = "Serum free light chain: lambda portion",
                        #      flc.grp = "FLC group",
                        #      creatinine = "Serum creatinine",
                        #      mgus = "Monoclonal gammapothy diagnosis",
                        #      futime = "Time from enrolment until death (days)",
                        #      chapter = "Primary cause of death"
                        #    )) #%>%
  desctable::desc_output("DT")
```

## ii) Output table

```{r}
sumtab4
```

## iii) Comments

-   **Pros**
    -   Interactive table
    -   Can copy output directly to clipboard, excel (with interactive button)
-   **Cons**
    -   Must specify grouping variables outside of the `desctable` environment
    -   Is slooow.
    -   Specification of tests are a little clunky and troublesome with categorical factors.
    -   Specification of statistics between categorical and continuous variables are a little clunky (shows IQR for categorical variables, etc.)

<br>

# 5) `summarytools::dfSummary`

## i) Render table

```{r echo = T, results = "asis", cache = FALSE}
flchain_mod <- flchain

label(flchain_mod$age)        <- "Age (years)"
label(flchain_mod$sex)        <- "Sex"
label(flchain_mod$sample.yr)  <- "Sample Year"
label(flchain_mod$kappa)      <- "Serum free light chain: kappa portion"
label(flchain_mod$lambda)     <- "Serum free light chain: lambda portion"
label(flchain_mod$flc.grp)    <- "FLC group"
label(flchain_mod$creatinine) <- "Serum creatinine"
label(flchain_mod$mgus)       <- "Monoclonal gammapothy diagnosis"
label(flchain_mod$futime)     <- "Time from enrolment until death (days)"
label(flchain_mod$chapter)    <- "Primary cause of death"

sumtab5 <- flchain %>%
  group_by(death) %>%
  summarytools::dfSummary(round.digits = 2,
                          varnumbers = FALSE,
                          na.col = TRUE,
                          style = "multiline",
                          plain.ascii = FALSE, # Recommended when rendering to markdown
                          headings = FALSE, 
                          labels.col = TRUE
                          ) %>%
  base::print(., method = "render")
```

## ii) Output table

```{r}
sumtab5
```

## iii) Comments

-   **Pros**
    -   Has some pretty cool graphs
-   **Cons**
    -   A bit fiddly to render nicely in RMarkdown. Requires specification of additional arguments in chunk header (`results = asis`)
    -   Stratification is clunky in output, and requires manual `group_by` argument.

<br>

# Conclusions

TBD

<br>

## Acknowledgements

Thanks to Wesley Billingham, Matt Cooper, and Elizabeth McKinnon for providing feedback on and reviewing this post.

You can look forward to seeing posts from these other team members here in the coming weeks and months.

<br>

## Reproducibility Information

To access the .qmd (Quarto markdown) files as well as any R scripts or data that was used in this post, please visit our GitHub:

<https://github.com/The-Kids-Biostats/The-Kids-Biostats.github.io/tree/main/posts/>

The session information can also be seen below.

```{r echo = T}
sessionInfo()
```

```{r echo = F , warning = F, message = F, error = F}
rm(trials, results, i, j, model, outcome_vars, input_vars, start, end, ind, bootstrap_results, bootstrap_coefs, bootstrap_cis, mtcars, result, month_dat, flights)
```
